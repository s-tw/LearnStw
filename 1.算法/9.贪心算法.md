# 贪心算法

# 思想

每种算法都有自己的算法思路，其中贪心算法的思想其实就是利用局部最优解一步一步达到全局最优解的情况。

这是一种比较特殊的思想，和动态规划有相似的地方，都是利用子问题的解来求得更大问题的解，不过不同的是动态规划往往是利用某种公式（递推方程）来求得的，而且往往也不一定是直接利用子问题的最优解。

而贪心不同，我们每一步求解其实都是一种最优情况，并且一定是可以直接作用于下一个阶段，并且可以直接求出全局的最优解。

# 例题

## [跳跃游戏（45）](https://leetcode-cn.com/problems/jump-game-ii/)

给定一个非负整数数组，你最初位于数组的第一个位置。

数组中的每个元素代表你在该位置可以跳跃的最大长度。

你的目标是使用最少的跳跃次数到达数组的最后一个位置。

假设你总是可以到达数组的最后一个位置。

![image-20210425221537666](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210425221537666.png)

### 思路

这是一道典型的贪心思想的算法。
每次我们都在可以探寻的范围中找到，可以向外衍生最远的那个点作为下一个落脚点作为我们新的落脚点。
例如[2,3,1,1,4]例子
一开始我们的落脚点是2，可以找的落脚点有a[1]，a[2],他们可以向外衍生的距离是3，1；
而衍生最远距离分别是4，3也就是1+a[1],2+a[2];
由此我们在选择落脚点的时候，就选择能衍生最远的落脚点a[1];
所以这道题的做法就出来了。
当我们的当前落脚点的衍生范围已经到了目的地，就说明我们不需要寻找新的落脚点，直接返回可以。
如果达不到目的地，我们需要找到新的落脚点，而新的落脚点的寻找方法就是利用能达到最远距离的那个点就是新的落脚点。

### 解法：贪心算法

```java
class Solution {
    public int jump(int[] nums) {
        int sum=1;
        for(int i=0;i<nums.length-1;){
            int max=i+nums[i];
            if(max>=nums.length-1)return sum;
            int temp=i;
            for(int j=i+1;j<nums.length&&j<=nums[i]+i;j++){
                if(max<j+nums[j]){
                    max=j+nums[j];
                    temp=j;
                }
            }
            i=temp;
            sum++;
        }
        return 0;
    }
}
```

