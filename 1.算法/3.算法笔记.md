# 单调栈

## 每日温度（739） 

### 题目描述

请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

### 解法1暴力

```java
public int[] dailyTemperatures(int[] T) {
    int[] num=new int[T.length];
    int len=T.length;
    for(int i=0;i<len;i++){
        int k=i+1;
        while(k<len&&T[k]<=T[i]){
            k++;
        }
        if(k!=len)
            num[i]=k-i;
    }
    return num;
}
```

### 解法2 单调栈（推荐）

解法思路：

由题意可知，如果气温都是单调递减的话，则得到的结果就都是0，所以我们可以设置的单调栈是单调递减的，**注：单调递减的是数组的值，我们存的是数组下标**。

每一天都与前一天比较

* 如果小于，符合单调栈，入栈
* 如果大于，不符合，循环出栈，利用存的下标相减的得到结果。

```java
public int[] dailyTemperatures(int[] T) {
    Deque<Integer> st = new ArrayDeque<>();
    int len = T.length;
    int[] temArr = new int[len];
    for (int i = 0; i < len; i++)
    {
        while (!st.isEmpty() && T[i] > T[st.peek()])
        {
            int top = st.pop();
            temArr[top] = i - top;
        }
        st.push(i);
    }
    return temArr;
}
```

# 滑动窗口

## 无重复字符的最长字串（3）

### 题目描述

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

* 示例 1:
  * 输入: s = "abcabcbb"
    输出: 3 
    解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。。

### 解法（滑动窗口）：

思路：

* 分析题意，
  * 大致可以确定用双指针，一个指向子串的的头，一个指向子串的尾。
  * 模拟执行，对于”abcabcbb“
  * 尾指针到”abc“的c，没有问题
  * 到a，发现重复了，我们需要将头指针指向第一个出现a的下一个位置。
  * 这里有另外一种情况，就是类似dabcab“类似这种
    * 也就是遇到重复了，头指针移动的位置大于1
  * 题目大致分析完成
* 选择数据结构
  * 这里选择HashSet，原因：set不允许重复的元素，符合要求
* 题解思路
  * 头指针在头部，尾指针也在头部
  * 当set不含有下一个元素，将元素加入set
  * 但含有下一个元素是，需要将头指针指向重复元素的下一个元素
    * 这里需要用循环，因为头指针可能需要移动多次
    * 注：移动时需要将set里面的元素remove出来

```java
Set<Character> occ = new HashSet<Character>();
int n = s.length();
// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
int rk = -1, ans = 0;
for (int i = 0; i < n; ++i) {
    if (i != 0) {
        // 左指针向右移动一格，移除一个字符
        occ.remove(s.charAt(i - 1));
    }
    while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {
        // 不断地移动右指针
        occ.add(s.charAt(rk + 1));
        ++rk;
    }
    // 第 i 到 rk 个字符是一个极长的无重复字符子串
    ans = Math.max(ans, rk - i + 1);
}
return ans;
```

# 找到下标移位法（瞎编的）

## 找到所有数组中消失的数字（448）

### 题目描述

给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

**示例:**

* 输入:[4,3,2,7,8,2,3,1]
* 输出:[5,6]

### 解法1：找到下标移位法

思想：找到这个数（a数）应该在的位置，将那个位置的数(b数)拿出来，把a放进去，然后在找b应该在的位置，一直找下去

```java
public List<Integer> findDisappearedNumbers(int[] nums) {
    int len=nums.length;
    List<Integer> list=new ArrayList<Integer>();
    for(int i=0;i<len;i++){
        int j=i;
        int temp=nums[j];
        while(temp!=j+1){
            int temp2=nums[temp-1];
            nums[temp-1]=temp;
            j=temp-1;
            temp=temp2;
        }
    }
    for(int i=0;i<len;i++){
        if(i!=nums[i]-1){
            list.add(i+1);
        }
    }
    return list;
}
```

### 解法2

```java
public List<Integer> findDisappearedNumbers(int[] nums) {
    int n = nums.length;
    for (int num : nums) {
        int x = (num - 1) % n;
        nums[x] += n;
    }
    List<Integer> ret = new ArrayList<Integer>();
    for (int i = 0; i < n; i++) {
        if (nums[i] <= n) {
            ret.add(i + 1);
        }
    }
    return ret;
}
```

# 二叉树

## 合并二叉树

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点

![image-20210302185919679](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210302185919679.png)

解法略

## 二叉树直径 （543）

给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

 ![image-20210302190944631](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210302190944631.png)

## 二叉树的最大深度（104）

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

**说明:** 叶子节点是指没有子节点的节点。

![image-20210311120155780](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210311120155780.png)

解法一：深度优先算法：可以利用递归

解法二：广度优先算法：需要利用队

# 动态规划

## 爬楼梯（70）

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

![image-20210308172048601](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210308172048601.png)

```java
 public int climbStairs(int n) {
        if(n<=2)return n;
        int[] tem=new int[n];
        tem[0]=1;
        tem[1]=2;
        for(int i=2;i<n;i++){
            tem[i]=tem[i-1]+tem[i-2];
        }
        return tem[n-1];
    }
```



## 最大子序和（53）

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

![image-20210302202228834](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210302202228834.png)

```java
public int maxSubArray(int[] nums) {
    int len=nums.length;
    int[] tt=new int[len];
    tt[0]=nums[0];
    int max=tt[0];
    for(int i=1;i<len;i++){
        tt[i]=Math.max(tt[i-1]+nums[i],nums[i]);
        if(tt[i]>max)max=tt[i];
    }
    return max;
}
```

## 最长回文子串（5）

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

![image-20210308162846441](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210308162846441.png)

### 解法1：动态规划

思想：如果一个字符串是回文字串，那么他的字串一定也是回文字符串，且本身的头尾相等

得到状态转移方程：对于dp[i,j]=（dp[i+1,j-1]&&dp[i]==dp[j]）

```java
public String longestPalindrome(String s) {
    int len=s.length();
    boolean[][] boo=new boolean[len][len];
    int begin=0;
    int last=0;
    for(int i=0;i<len;i++){
        for(int j=0;j<i;j++){
            if(i==j){
                boo[i][j]=true;
            }
            if(j<i-2){ if(s.charAt(i)==s.charAt(j)&&boo[i-1][j+1])
                boo[i][j]=true;
                     }else if(j<i){
                if(s.charAt(i)==s.charAt(j))
                    boo[i][j]=true;
            }
            if(boo[i][j]&&i-j>last-begin)
            {
                last=i;
                begin=j;
            }
        }
    }
    return s.substring(begin,last+1);
}

```

### 解法2 中心扩散

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) {
        return "";
    }
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

public int expandAroundCenter(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        --left;
        ++right;
    }
    return right - left - 1;
}

```

## 买卖股票的最佳时机（121）

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

![image-20210309192448471](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210309192448471.png)

### 解法1：利用题目特性解

```java
public int maxProfit(int[] prices) {
    int min=0;
    int max=0;
    int sum=0;
    int len=prices.length;
    for(int i=1;i<len;i++){
        if(prices[i]<prices[min]&&prices[i]<prices[i-1]){
            min=i;
            max=i;
        }
        if(prices[i]>prices[max]&&prices[i]>prices[i-1]){
            max=i;
        }
        if(prices[max]>prices[min]&&min<max)sum=Math.max(sum,prices[max]-prices[min]);
    }
    return sum;
}
```

### 解法2：动态规划

思路：动态规划 前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}

```java
public int maxProfit(int[] prices) {
    int min=prices[0];
    int len=prices.length;
    int sum=0;
    for(int i=0;i<len;i++){
        sum=Math.max(sum,prices[i]-min);
        if(prices[i]<min)min=prices[i];
    }
    return sum;
}
```



# 双指针

## 环形链表（141）

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

![image-20210311115340591](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210311115340591.png)

### 解法1：hashmap

思想：一直向hashmap里面放值，如果出现相同的值就证明有环。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
```

### 解法2：双指针

思想：利用快慢指针，如果出现环，快指针与慢指针迟早会重合。由于没有读写操作，其实速度会更快

```java
 public boolean hasCycle(ListNode head) {
        if(head!=null&&head.next!=null);
        ListNode temp=head;
        ListNode temp2=head;
        while(temp!=null&&temp.next!=null){
            temp=temp.next.next;
            temp2=temp2.next;
            if(temp2==temp)return true;
        }
        return false;
    }
```

## 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

![image-20210309124044686](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210309124044686.png)

### 解法：双指针

思路复习：其实是有三个指针，分别指代三个数

* 分析题意，可以发现用sort排序一下会更好
* 第一个指针固定，后面两个指针取求和和第一个数累加
  * 如果等于0说明有解
  * 大于0，说明尾数太大，尾数减
  * 小于0，说明第二个指针太小，第二个加
  * 注:题目中说了去要去重，所以解决题目时候要注意去重
* 简单的分析可得，如果第一个指针大于0，表明其他两个指针一定也大于0，所以可以舍去

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> lists=new ArrayList<List<Integer>>();
    Arrays.sort(nums);
    int len=nums.length;
    for(int i=0;i<len-2;i++){
        if(i>0&&nums[i]==nums[i-1])continue;
        int j=i+1;
        int last=len-1;
        int t=-nums[i];
        if(t<0)return lists;
        while(j<last){
            if(nums[j]+nums[last]<t){
                j++;
            }else if(nums[j]+nums[last]>t){
                last--;
            }else{
                List<Integer> list=new ArrayList<Integer>();
                list.add(nums[i]);
                list.add(nums[j]);
                list.add(nums[last]);
                lists.add(list);
                while(j<last&&nums[j]==nums[j+1])j++;
                while(j<last&&nums[last]==nums[last-1])last--;
                j++;
                last--;
            }
            if(nums[last]<0)break;
        }
    }
    return  lists;
}
```



# 回溯法

## 全排列（46）

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

![image-20210310200444006](%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0.assets/image-20210310200444006.png)

```java
public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> lists=new ArrayList<List<Integer>>();
        List<Integer> list=new ArrayList<Integer>();
        for(int i:nums){
            list.add(i);
        }
        change(nums.length,lists,list,0);
        return lists;
    }
    public void change(int n,List<List<Integer>> lists,List<Integer> list,int index){
        if(n==index){
            
            lists.add(new ArrayList<Integer>(list));
        }
        for(int i=index;i<n;i++){
            Collections.swap(list,index,i);
            change(n,lists,list,index+1);
            Collections.swap(list,index,i);
        }
    }
```



# 经典题目

## 反转单链表

### 1，普通解法

```java
public ListNode reverseList(ListNode head) {
    ListNode linked=new ListNode();
    while(head!=null){
        ListNode tt=new ListNode(head.val);
        tt.next=linked.next;
        linked.next=tt;
        head=head.next;
    }
    return linked.next;
}
```

### 2，迭代解法

```java
public ListNode reverseList(ListNode head) { 
    ListNode linked=new ListNode();
    ListNode node=head;
    while(head!=null){
        head=head.next;
        node.next=linked.next;
        linked.next=node;
        node=head;
    }
    return linked.next;
}
```

### 3，递归解法

```java
public ListNode reverseList(ListNode head) {
    if(head==null||head.next==null)return head;
    ListNode newHead=reverseList(head.next);
    head.next.next=head;
    head.next=null;
    return newHead;
}
```

