# 动态规划

## 爬楼梯（70）

假设你正在爬楼梯。需要 *n* 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**注意：**给定 *n* 是一个正整数。

![image-20210308172048601](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210308172048601.png)

```java
 public int climbStairs(int n) {
        if(n<=2)return n;
        int[] tem=new int[n];
        tem[0]=1;
        tem[1]=2;
        for(int i=2;i<n;i++){
            tem[i]=tem[i-1]+tem[i-2];
        }
        return tem[n-1];
    }
```



## 最大子序和（53）

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

![image-20210302202228834](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210302202228834.png)

```java
public int maxSubArray(int[] nums) {
    int len=nums.length;
    int[] tt=new int[len];
    tt[0]=nums[0];
    int max=tt[0];
    for(int i=1;i<len;i++){
        tt[i]=Math.max(tt[i-1]+nums[i],nums[i]);
        if(tt[i]>max)max=tt[i];
    }
    return max;
}
```

## 最长回文子串（5）

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

![image-20210308162846441](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210308162846441.png)

### 解法1：动态规划

思想：如果一个字符串是回文字串，那么他的字串一定也是回文字符串，且本身的头尾相等

得到状态转移方程：对于dp[i,j]=（dp[i+1,j-1]&&dp[i]==dp[j]）

```java
public String longestPalindrome(String s) {
    int len=s.length();
    boolean[][] boo=new boolean[len][len];
    int begin=0;
    int last=0;
    for(int i=0;i<len;i++){
        for(int j=0;j<i;j++){
            if(i==j){
                boo[i][j]=true;
            }
            if(j<i-2){ if(s.charAt(i)==s.charAt(j)&&boo[i-1][j+1])
                boo[i][j]=true;
                     }else if(j<i){
                if(s.charAt(i)==s.charAt(j))
                    boo[i][j]=true;
            }
            if(boo[i][j]&&i-j>last-begin)
            {
                last=i;
                begin=j;
            }
        }
    }
    return s.substring(begin,last+1);
}

```

### 解法2 中心扩散

```java
public String longestPalindrome(String s) {
    if (s == null || s.length() < 1) {
        return "";
    }
    int start = 0, end = 0;
    for (int i = 0; i < s.length(); i++) {
        int len1 = expandAroundCenter(s, i, i);
        int len2 = expandAroundCenter(s, i, i + 1);
        int len = Math.max(len1, len2);
        if (len > end - start) {
            start = i - (len - 1) / 2;
            end = i + len / 2;
        }
    }
    return s.substring(start, end + 1);
}

public int expandAroundCenter(String s, int left, int right) {
    while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
        --left;
        ++right;
    }
    return right - left - 1;
}

```

## 买卖股票的最佳时机（121）

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

![image-20210309192448471](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210309192448471.png)

### 解法1：利用题目特性解

```java
public int maxProfit(int[] prices) {
    int min=0;
    int max=0;
    int sum=0;
    int len=prices.length;
    for(int i=1;i<len;i++){
        if(prices[i]<prices[min]&&prices[i]<prices[i-1]){
            min=i;
            max=i;
        }
        if(prices[i]>prices[max]&&prices[i]>prices[i-1]){
            max=i;
        }
        if(prices[max]>prices[min]&&min<max)sum=Math.max(sum,prices[max]-prices[min]);
    }
    return sum;
}
```

### 解法2：动态规划

思路：动态规划 前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}

```java
public int maxProfit(int[] prices) {
    int min=prices[0];
    int len=prices.length;
    int sum=0;
    for(int i=0;i<len;i++){
        sum=Math.max(sum,prices[i]-min);
        if(prices[i]<min)min=prices[i];
    }
    return sum;
}
```



# 双指针

## 环形链表（141）

给定一个链表，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。

如果链表中存在环，则返回 true 。 否则，返回 false 。

![image-20210311115340591](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210311115340591.png)

### 解法1：hashmap

思想：一直向hashmap里面放值，如果出现相同的值就证明有环。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        Set<ListNode> seen = new HashSet<ListNode>();
        while (head != null) {
            if (!seen.add(head)) {
                return true;
            }
            head = head.next;
        }
        return false;
    }
}
```

### 解法2：双指针

思想：利用快慢指针，如果出现环，快指针与慢指针迟早会重合。由于没有读写操作，其实速度会更快

```java
 public boolean hasCycle(ListNode head) {
        if(head!=null&&head.next!=null);
        ListNode temp=head;
        ListNode temp2=head;
        while(temp!=null&&temp.next!=null){
            temp=temp.next.next;
            temp2=temp2.next;
            if(temp2==temp)return true;
        }
        return false;
    }
```

## 三数之和

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

![image-20210309124044686](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210309124044686.png)

### 解法：双指针

思路复习：其实是有三个指针，分别指代三个数

* 分析题意，可以发现用sort排序一下会更好
* 第一个指针固定，后面两个指针取求和和第一个数累加
  * 如果等于0说明有解
  * 大于0，说明尾数太大，尾数减
  * 小于0，说明第二个指针太小，第二个加
  * 注:题目中说了去要去重，所以解决题目时候要注意去重
* 简单的分析可得，如果第一个指针大于0，表明其他两个指针一定也大于0，所以可以舍去

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> lists=new ArrayList<List<Integer>>();
    Arrays.sort(nums);
    int len=nums.length;
    for(int i=0;i<len-2;i++){
        if(i>0&&nums[i]==nums[i-1])continue;
        int j=i+1;
        int last=len-1;
        int t=-nums[i];
        if(t<0)return lists;
        while(j<last){
            if(nums[j]+nums[last]<t){
                j++;
            }else if(nums[j]+nums[last]>t){
                last--;
            }else{
                List<Integer> list=new ArrayList<Integer>();
                list.add(nums[i]);
                list.add(nums[j]);
                list.add(nums[last]);
                lists.add(list);
                while(j<last&&nums[j]==nums[j+1])j++;
                while(j<last&&nums[last]==nums[last-1])last--;
                j++;
                last--;
            }
            if(nums[last]<0)break;
        }
    }
    return  lists;
}
```



# 回溯法

## 全排列（46）

给定一个 **没有重复** 数字的序列，返回其所有可能的全排列。

![image-20210310200444006](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210310200444006.png)

```java
public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> lists=new ArrayList<List<Integer>>();
        List<Integer> list=new ArrayList<Integer>();
        for(int i:nums){
            list.add(i);
        }
        change(nums.length,lists,list,0);
        return lists;
    }
    public void change(int n,List<List<Integer>> lists,List<Integer> list,int index){
        if(n==index){
            
            lists.add(new ArrayList<Integer>(list));
        }
        for(int i=index;i<n;i++){
            Collections.swap(list,index,i);
            change(n,lists,list,index+1);
            Collections.swap(list,index,i);
        }
    }
```



# 经典题目

## 反转单链表

### 1，普通解法

```java
public ListNode reverseList(ListNode head) {
    ListNode linked=new ListNode();
    while(head!=null){
        ListNode tt=new ListNode(head.val);
        tt.next=linked.next;
        linked.next=tt;
        head=head.next;
    }
    return linked.next;
}
```

### 2，迭代解法

```java
public ListNode reverseList(ListNode head) { 
    ListNode linked=new ListNode();
    ListNode node=head;
    while(head!=null){
        head=head.next;
        node.next=linked.next;
        linked.next=node;
        node=head;
    }
    return linked.next;
}
```

### 3，递归解法

```java

public ListNode reverseList(ListNode head) {
    if(head==null||head.next==null)return head;
    ListNode newHead=reverseList(head.next);
    head.next.next=head;
    head.next=null;
    return newHead;
}
```

