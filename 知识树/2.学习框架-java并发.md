# 上下文切换

## 减少上下文切换的方法

-   无锁并发编程

    -   将数据id安装hash取分段，不同线程处理不同段的数据

-   cas算法

-   使用最少线程

-   协程

## 什么是上下文切换

# 死锁

## 死锁的条件

-   互斥条件

-   请求和保持

-   不可抢占

-   循环等待

## 什么是死锁

## 如何解决死锁

-   死锁预防
-   死锁避免

    -   银行家算法
-   死锁检测
-   死锁解除

    -   剥夺资源

    -   撤销进程

# 进程线程协程

## 进程 

进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。进程是一种抽象的概念，从来没有统一的标准定义。

进程一般由程序、数据集合和进程控制块三部分组成。

## 进程之间的通信

* **管道通信**

  1. 只能单向通信

  2. 只能血缘关系的进程进行通信

  3. 依赖于文件系统
  4. 生命周期随进程

  5. 面向字节流的服务

  6. 管道内部提供了同步机制

* **信号量机制**：信号量是一个计数器，可以用来控制多个进程对共享资源的访问

* **信号**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

* **消息队列：**消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

* **共享内存**：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问

* **套接字**：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

## 线程

线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)

## 线程之间的通信

* 锁机制
* 信号量机制
* 信号机制
* violate
* wait/notify

## 进程与线程的区别

  前面讲了进程与线程，但可能你还觉得迷糊，感觉他们很类似。的确，进程与线程有着千丝万缕的关系，下面就让我们一起来理一理：

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；
2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；
3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段、数据集、堆等)及一些进程级的资源(如打开文件和信号)，某进程内的线程在其它进程不可见；
4. 调度和切换：线程上下文切换比进程上下文切换要快得多。

## 协程

一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）

协程看上去也是子程序，但执行过程中，在子程序内部可中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。

# synchronized

## synchronized的具体表现

* 普通同步方法：当前实例对象
* 静态同步方法：类的class对象
* 同步方法块：括号中的配置的对象

## 存在对象头

## 四种锁状态

* 无锁状态

* 偏向锁
  * 偏向锁机制
  * 偏向锁的撤销

-   轻量级锁

    -   锁升级
-   重量级锁

## 锁升级

# volatile

## 可见性

-   确保所有线程看到的变量值是一致的

## 如何确保可见性

-   汇编时会生成lock前缀
-   lock前缀会引起处理器缓存写回到内存
-   一个处理器的缓存回写到内存会导致其他处理器的缓存无效

## happeds-before关系

## 读写内存语义

## 内存语义实现

-   内存屏障

# 原子操作

## 处理机如何实现原子操作

-   总线锁保证原子性

-   缓存锁定保证原则性

## java实现原子操作

### CAS

CAS的三大问题

* ABA问题
  * 使用版本号
* 循环时间长开销大
  * jvm的pause指令
* 只能保证一个共享变量的原子操作
  * 将多个共享变量合并一个共享变量

### 锁

# 缓存一致性协议（MESI）

## **多核CPU多级缓存一致性协议MESI**

多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI。

**MESI协议缓存状态**

MESI 是指4中状态的首字母。每个Cache line有4个状态，可用2个bit表示，它们分别是：

**缓存行（Cache line）**:缓存存储数据的单元

| 状态                     | 描述                                                         | 监听任务                                                     |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| M修改（Modified）        | 该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中 | 缓存行必须时刻监听所有试图读该缓冲行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行 |
| E独享，互斥（Exclusive） | 该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。 | 缓存行也必须监听其他缓存读主存中缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态 |
| S共享（Shared）          | 该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。 | 缓存行也必须监听其他缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid） |
| I无效（Invalid）         | 该Cache line无效                                             | 无                                                           |



# JMM



## 两个关键问题

-   线程之间如何通信

-   线程之间如何同步


## JMM抽象结构

-   JMM控制主内存和每个线程的本地内存之间的交互，来为java程序员提供内存可见性

## 重排序

-   编译器重排序

-   指令级别的重排序

-   内存系统的重排序

-   jmm通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证

## 并发编程模型的分类

## happens-before

-   程序顺序规则

-   监视器锁规则

-   volatile

## 重排序

-   数据依赖性

-   as-if-serial

    -   程序执行结果不能被改变

-   程序顺序规则

-   重排序对多线程的影响

    -   对存在控制依赖操作的重排序，可能会改变程序的执行结果

## 顺序一致性

-   数据竞争与顺序一致性

-   顺序一致性内存模型

    -   两大特性

        -   一个线程中的所有操作必须按照程序顺序执行

        -   所有线程只能看到单一操作顺序，每个操作必须原子执行且立刻对所有线程可见

    -   注：JMM没有这个保证，基本方针，不改变程序执行结果前提下，尽量优化

-   未同步程序执行特性

    -   最小安全性

## 锁的内存语义

-   happends-before关系

-   锁释放和获得的内存语义

    -   利用volatile变量写读所具有的内存语义
-   利用cas所附带的volatile读和volatile写的内存语义

## 双重检查锁定与延迟初始化

-   问题根源

-   解决方式

## 综述

-   处理机内存模型

-   各种内存模型之间的关系

-   jmm内存可见性保证

    -   单线程程序

    -   正确的多线程程序

    -   未同步的多线程程序

        -   最小安全

-   旧模型修补

    -   增强volatile的内存语义

    -   增强final的内存语义

# 线程使用

## 线程的概念

## 为什么要使用多线程

## 线程优先级：Priority

## 线程的状态

初始、运行、阻塞、等待、超时等待、终止状态

## Daemon线程（守护线程）

## 线程的方法

-   构建线程

-   启动线程

-   中断

-   过期的方法（suspend(),resume(),stop()）

-   安全的终止方法

## 线程之间的通信

### volatile和synchronized关键字

### 等待/通知机制

-   notify()

-   wait()

-   经典范式

    -   等待原则

        -   获取锁

        -   条件不满足，调用wait()，被通知后，也就要检查条件

        -   条件满足执行逻辑

    -   通知原则

        -   获得对象的锁

        -   改变对象

        -   通知 所有等待在对象上的线程

### 管道输入/输出流

-   面向字节

    -   PipedOutputStream

    -   PipedInputSteam

-   面向字符

    -   PipedReader

    -   PipedWrier

## Thread.join()

## ThreadLocal

## 线程应用实例

-   等待超时模式

-   数据库连接池

-   线程池

# 锁

## Lock接口

-   显示的获取和释放锁

## ABS

- 结构

  - int成员变量

  - FIFO队列

    CAS设置尾节点/设置头结点不需要CAS

- 支持

  -   独占式获得同步状态

  -   共享式获得同步状态

- 模板方法模式

  -   独占式获取与释放同步状态

      -   对中断不敏感

  -   共享式获取与释放同步状态

      -   释放也要安全释放:循环和CAS

  -   查询同步队列中的等待线程状态

## 重入锁：ReentrantLock

-   重进入

-   公平锁和非公平锁

-   读写锁

    -   读写锁的状态设计

    -   写锁的获取和释放

    -   读锁的获取和释放

    -   锁降级：写-\>读

-   LockSupport

-   Condition接口

    -   等待/通知

    -   依赖于Lock对象

    -   实现

        -   等待队列

        -   等待

        -   通知

# 并发容器和框架

## ConcurrentHashMap 1.7/1.8

-   结构

-   初始化

-   put操作

-   get操作

-   size

## ConcurentLinkedQueue

-   结构

-   入队方式

-   出队

-   阻塞队列：BlockingQueue

    -   java中阻塞队列

        -   有界阻塞队列

            -   ArrayBlocking Queue

            -   LinkedBlockingQueue

        -   无界阻塞队列

            -   PriorityBlockingQueue

            -   DelayQueue

            -   LinkedTransferQueue

        -   不存储元素阻塞队列

            -   SynchronousQueue

        -   双向阻塞队列

            -   LinkedBLockingDeque

    -   实现原理

        -   通知模式

## Fork/Join

### 概念

-   切割，汇总

### 工作窃取算法

-   优点

-   缺点

-   设计

    -   分割任务

    -   执行任务并且合并结果

# 并发工具类

-   CountDownLatch
-   CyclicBarrier
-   Semaphore
-   Exchanger

# 线程池

## 为啥要用线程池（好处）

## 处理线程的流程

## 线程池的创建（核心参数）

-   corePoolSize（线程池的大小）

-   runableTaskQueue(任务队列)

-   maximumPoolSize（线程池最大数量）

-   ThreadFactory(线程工厂)

-   RejectedExecutionHandler（饱和策略）

-   keepAliveTime（空闲线程存活时间）

-   unit空闲线程存货时间单位

## 向线程池提交的方法

-   execute（）

-   submit（）

## 如何关闭线程池

-   shutdown（）

-   shutdownNow（）

## 配置线程池应该注意什么

## 线程池的监视方法

-   taskCount：线程池需要执行的任务数量

-   completedTaskCount：线程池在运行过程中完成的任务数量

-   largestPoolSize：线程池曾经创建果的最大线程数量

    -   可以判断线程池是否满过

-   getPoolSize:线程池的线程数量

-   getActiveCount：获取活动的线程数

