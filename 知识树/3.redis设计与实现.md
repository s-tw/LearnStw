## 简单动态字符串

### SDS

```c
struct sdshdr{
    //记录buf数组中 已使用字节的数量
    //等于SDS所保存字符串的长度
    int len;
    //记录buf数组中未使用字节的数量
    int free;
    //字节数组，用于保存字符串
    char buf[]
}sdshdr;
```

### SDS与C字符串的区别

* **获取字符串长度的复杂度不同**，

  * SDS为O(1),C为O(N)

* **杜绝缓存区溢出**

  * 由于不记录长度，在执行拼接字符串时候，会存在数据溢出的错误。
  * SDS会检查空间是否满足修改所需的要求，如果不够，会扩展SDS的空间，在拼接

* **减少修改字符串是带来的内存重分配次数**

  * c语言的内存重分配机制

    * **增长操作**，需要内存重分配来扩展底层数组空间大小，否则会产生缓存区溢出
    * **缩短操作**，需要释放不在使用的空间，否则会产生内存泄露

  * SDS中存在free属性在记录未使用字节数。

    * **空间预分配**

      不仅会分配必须要的空间，还会为SDS分配额外的未使用空间。

      ​	**公式：**

      SDS长度小于1MB，分配相同大小的长度

      SDS长度大于1MB，分配1MB的free长度

    * **惰性空间释放**

      实际上并不释放空间，而是增加free的长度

* **二进制安全**

  * c中字符串只能保存文本，不能保存二进制数据。

    * 例如如果出现

      ![image-20210506224819242](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506224819242.png)

    * c字符串只能识别“Redis”会忽略后面的"Cluster"

  * SDS的api会以处理二进制的方式来处理数组的数据。写入时是什么样，读出就是什么样。

* **兼容部分c字符串函数**

  * 爆裂数据末尾的空字符，以保证可以重用一部分< String.h>库定义的函数。
  * 

### 总结

![image-20210506225247182](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225247182.png)

![image-20210506225342615](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225342615.png)

![image-20210506225353031](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225353031.png)

## 链表

### 链表的实现

**节点实现**

```c
typedef struct listNode{
    //前置结点
    struct listNode * prev;
    //后置结点
    struct listNode * next;
    //节点的值
    void * value;
}listNode;
```

**链表实现**

```c
typedef struct list{
    //表头节点
    struct listNode * head;
    //表尾节点
    struct listNode * tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数
    void *(*dup)(void * ptr);
    //节点值释放函数
    void *(*free)(void * ptr);
    //节点值比较函数
    int (*match)(void *ptr,void *key)
}list;
```

### 结构示意图

![image-20210507092036078](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092036078.png)

### 链表特性

* 双端:链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是0(1)。
* 无环:表头节点的prev指针和表尾节点的next指针都指向NULL,对链表的访问以NULL为终点。
* 带表头指针和表尾指针:通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为0(1)。
* 带链表长度计数器:程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为0(1)。
* 多态:链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

### 总结

![image-20210507092154901](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092154901.png)

![image-20210507092219381](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092219381.png)

![image-20210507092229887](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092229887.png)

## 字典

### 字典的实现

Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

```c
typedef struct dict{
    
    //类型特定函数
    dicType *type;
    
    //私有数据
    void *privdata;
    
    //哈希表
    dictht ht[2];
    
    //rehash 索引
    //当rehash不在进行时，值为-1；
    in trehashidx;
}
```

```c
typedef  struct dictType{
    
    //计算哈希值的函数
    unsigned int (*hashFunction){const void * key};
    
    //复制键的函数
    void *(*keyDup){void *privdata,const void *key};
    
    //复制值的函数
    void *(*valDup){void *privdata,const void *obj};
    
    //对比键的函数
    int (*keyCompare){void *privdata,const void *key1,const void *key2};
    
    //销毁键的函数
    void (*keyDestructor){void *privdata,void *key};
    
    //销毁值的函数
    void (*valDestructor){void *privdata,void *obj};
    
}dictType;
```

