## 简单动态字符串

### SDS的实现

```c
struct sdshdr{
    //记录buf数组中 已使用字节的数量
    //等于SDS所保存字符串的长度
    int len;
    //记录buf数组中未使用字节的数量
    int free;
    //字节数组，用于保存字符串
    char buf[]
}sdshdr;
```

### SDS与C字符串的区别

* **获取字符串长度的复杂度不同**，

  * SDS为O(1),C为O(N)

* **杜绝缓存区溢出**

  * 由于不记录长度，在执行拼接字符串时候，会存在数据溢出的错误。
  * SDS会检查空间是否满足修改所需的要求，如果不够，会扩展SDS的空间，在拼接

* **减少修改字符串是带来的内存重分配次数**

  * c语言的内存重分配机制

    * **增长操作**，需要内存重分配来扩展底层数组空间大小，否则会产生缓存区溢出
    * **缩短操作**，需要释放不在使用的空间，否则会产生内存泄露

  * SDS中存在free属性在记录未使用字节数。

    * **空间预分配**

      不仅会分配必须要的空间，还会为SDS分配额外的未使用空间。

      ​	**公式：**

      SDS长度小于1MB，分配相同大小的长度

      SDS长度大于1MB，分配1MB的free长度

    * **惰性空间释放**

      实际上并不释放空间，而是增加free的长度

* **二进制安全**

  * c中字符串只能保存文本，不能保存二进制数据。

    * 例如如果出现

      ![image-20210506224819242](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506224819242.png)

    * c字符串只能识别“Redis”会忽略后面的"Cluster"

  * SDS的api会以处理二进制的方式来处理数组的数据。写入时是什么样，读出就是什么样。

* **兼容部分c字符串函数**

  * 爆裂数据末尾的空字符，以保证可以重用一部分< String.h>库定义的函数。
  * 

### 总结

![image-20210506225247182](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225247182.png)

![image-20210506225342615](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225342615.png)

![image-20210506225353031](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225353031.png)

## 链表

### 链表的实现

**节点实现**

```c
typedef struct listNode{
    //前置结点
    struct listNode * prev;
    //后置结点
    struct listNode * next;
    //节点的值
    void * value;
}listNode;
```

**链表实现**

```c
typedef struct list{
    //表头节点
    struct listNode * head;
    //表尾节点
    struct listNode * tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数
    void *(*dup)(void * ptr);
    //节点值释放函数
    void *(*free)(void * ptr);
    //节点值比较函数
    int (*match)(void *ptr,void *key)
}list;
```

### 结构示意图

![image-20210507092036078](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092036078.png)

### 链表特性

* 双端:链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是0(1)。
* 无环:表头节点的prev指针和表尾节点的next指针都指向NULL,对链表的访问以NULL为终点。
* 带表头指针和表尾指针:通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为0(1)。
* 带链表长度计数器:程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为0(1)。
* 多态:链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

### 总结

![image-20210507092154901](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092154901.png)

![image-20210507092219381](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092219381.png)

![image-20210507092229887](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092229887.png)

## 字典

### 字典的实现

Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

#### 哈希表

```c
typedef struct dictht {
        //哈希表数组
        dictEntry **table;
        //哈希表大小
        unsigned long size;
        //哈希表大小掩码，用于计算索引值
        //总是等于size-1
        unsigned long sizemask; .
        //该哈希表已有节点的数量
        unsigned long used;
} dictht;

```

* table属性是一个数组，数组中的每个袁术都是指向dict.h/dictEntry 结构的指针，每个dictEntry结构保存着一个键值对，

* size属性记录了哈希表的大小，也就是table数组的大小

* used属性则记录了哈希表目前已有节点（键值对）的数量。

* sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面

* 图示一个大小为4的空哈希表（没有包括任何键值对）。

  ![image-20210516155817469](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516155817469.png)

#### 哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对。

```c
typedef struct dictEntry {
    //键
    void *key;
    //值
    union{
    	void val; .
    	uint64_ tu64;
    	int64_ ts64;
    } V;
    //指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;

```

​	key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是-一个指针，或者是-一个uint64_ t整数，又或者是-一个int64_ t整数。
​	next属性是指向另-一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突( collision)的问题。
​	举个例子，图4-2就展示了如何通过next指针，将两个索引值相同的键k1和k0连
接在一起。

![image-20210516160417669](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516160417669.png)

#### 字典

Redis中的字典始有dict.h/dict结构表示

```c
typedef struct dict{
    
    //类型特定函数
    dicType *type;
    
    //私有数据
    void *privdata;
    
    //哈希表
    dictht ht[2];
    
    //rehash 索引
    //当rehash不在进行时，值为-1；
    in trehashidx;
}
```

type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置。

* type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。
* 而privdata属性则保存了需要传给哪些类型特定函数的可选参数。

```c
typedef  struct dictType{
    
    //计算哈希值的函数
    unsigned int (*hashFunction){const void * key};
    
    //复制键的函数
    void *(*keyDup){void *privdata,const void *key};
    
    //复制值的函数
    void *(*valDup){void *privdata,const void *obj};
    
    //对比键的函数
    int (*keyCompare){void *privdata,const void *key1,const void *key2};
    
    //销毁键的函数
    void (*keyDestructor){void *privdata,void *key};
    
    //销毁值的函数
    void (*valDestructor){void *privdata,void *obj};
    
}dictType;
```

* ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表, 一般情况下，字典只使用ht [0]哈希表，ht[1] 哈希表只会在对ht [0]哈希表进行rehash时使用。
* 除了ht[1]之外，另一个和rehash有关的属性就是rehashidx,它记录了
  rehash目前的进度，如果目前没有在进行rehash,那么它的值为-1。

![image-20210516161933979](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516161933979.png)

### 哈希算法

​	当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

**redis计算哈希值和索引的方法如下：**

* 使用字典设置的哈希函数和哈希值，计算键key的哈希值

  hash=dict->type->hashFunction(key)

* 使用哈希表的sizemask属性和哈希值，计算出索引值

* 根据情况的不同，ht[x]可以是ht[0]或者是ht[1]

  index=hash&dict->ht[x].sizemask;

**例子：**

![image-20210516163517391](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516163517391.png)

对于以上这个字典，如果我们要将一个简直对k0和v0添加到字典里面，那么程序会先使用语句：

hash=dict->type->hashFunction(k0);

计算键k0的哈希值。

假设计算得出的哈希值为8，那么程序会继续使用语句：

index=hash&dict->ht[0].sizemask=8&3=8;

计算出键k0的索引值0，这表示包含键值对k0和v0的节点应该被放置到哈希表数组的索引0位置上，如下图所示

![image-20210516163951542](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516163951542.png)

### 解决键冲突

* 当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突( collision )。

* Redis的哈希表使用链地址法( separate chaining )来解决键冲突,每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。

* 举个例子，假设程序要将键值对k2和v2添加到图4-6所示的哈希表里面,并且计算得出k2的索引值为2，那么键k1和k2将产生冲突，而解决冲突的办法就是使用next指针将键k2和k1所在的节点连接起来，如图4-7所示。

* 因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑,程序总是将新节点添加到链表的表头位置(复杂度为0(1)),排在其他已有节点的前面。

  ![image-20210516164210560](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516164210560.png)

### rehash

#### rehash步骤

​	随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子( load factor)维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。
​	扩展和收缩哈希表的工作可以通过执行rehash (重新散列)操作来完成，Redis 对字典的哈希表执行rehash的步骤如下:

* 为字典的ht[1]哈希表分配空间,这个哈希表的空间大小取决于要执行的操作，以
  及ht[0]当前包含的键值对数量( 也即是ht [0] .used属性的值):
  * 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht [0] .used*2
    的2"(2的n次方幂);
  * 如果执行的是收缩操作,那么ht [1]的大小为第一个大于等于ht[0] .used的2"。
* 将保存在ht[0]中的所有键值对rehash到ht[1]上面: rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht [1]哈希表的指定位置上。
* 当ht[0]包含的所有键值对都迁移到了ht[1]之后(ht[0]变为空表),释放ht[0]，将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表,为下一次rehash做准备。

#### 收缩和扩展的条件

当以下条件中的任意一个被满足时, 程序会自动开始对哈希表执行扩展操作:

* 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令,并且哈希表的负载因子大于等于1。
* 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。
  * 根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制( copy-on-write )技术来优化子进程的使用效率,所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写人操作，最大限度地节约内存。
* 另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

### 渐进式rehash

#### 渐进式rehash的步骤

以下是哈希表渐进式rehash的详细步骤:

* 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
* 在字典中维持一个索引计数器变量rehashidx,并将它的值设置为0,表示rehash
  工作正式开始。
* 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
* 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。

渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

#### 渐进rehash时，哈希操作

因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除(delete)查找(fnd)、更新( update)等操作会在两个哈希表上进行。例如，要在字典里面查找-一个键的话,程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht [1]里面进行查找，诸如此类。
另外，在渐进式rehash执行期间,新添加到字典的键值对一律会被保存到ht[1]里面,而ht [0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。

### 总结

* 字典被广泛适用于redis的各种功能，包括数据库和哈希键。
* redis中的redis使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另外一个rehash时使用
* 当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis使用MurmurHash2算法来计算键的哈希值。
* 哈希表使用链地址法来解决键冲突，被分配到同一个索引的多个键值对会连接成一个单向链表。
* 在对哈希表进行扩展或者收缩时，程序需要将现有哈希表包括的所有键值对rehash到新的哈希表里面，并且这个rehash过程并不是一次性完成的，而是渐进式完成的。

## 跳跃表

### 跳跃表的实现

![image-20210517152439362](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517152439362.png)

* zskiplist 结构
  * header：指向跳跃表的表头
  * tail：指向跳跃表的表尾节点
  * level：记录目前跳跃表内，层数最大的那个节点的层数（表头结点的层数不计算在内）。
  * length：记录跳跃表的长度，也即是，跳跃表目前包含结点的数量（表头结点不计算在内）。
* zskipNode结构
  * level：每层都有两个属性，前进指针和跨度。
  * backward：后退指针，指向位于当前结点的前一个结点。
  * score：分值
  * obj：结点保存的成员对象

#### 跳跃表节点

```c
typedef struct zskiplistNode{
    //层
    struct zskiplistLevel{
        //前进指针
        struct zskiplistNode *forward;
        //跨度
        unsigned int span;
    }level[];
    //后退指针
    struct zskiplistNode *backward;
    //分值
    double score;
    //成员对象
    robj *obj;
}zskiplistNode;
```

* 层：level数组，包含指向其他结点的指针。
  * 程序根据幂次定律（越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level的数组大小，这个大小就是层的高度。
* 前进指针：定义为层中的forword
* 跨度：表示记录两个结点之间的距离。
  * 主要是为了计算排位，在查找结点的过程中，将沿途访问过的所有层的跨度累计起来，得到的就是目标结点的排位。
* 后退指针：从表尾到头的方向访问结点，只能访问前一个结点。
* 分值：double类型
* 成员对象obj：是一个指针，指向字符串对象。字符串对象保存一个sds值。

#### 跳跃表

```c
typedef struct zskiplist{
    //表头结点和表尾结点
    structz skiplistNode *header,*tail;
    //表中结点的数量
    unsigned long length;
    //表中层数最大的结点层数
    int level;
}zskiplist；
```

* header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为0(1)。
* 通过使用length属性来记录节点的数量,程序可以在0(1)复杂度内返回跳跃表的长度。
* level属性则用于在0(1)复杂度内获取跳跃表中层高最大的那个节点的层数量,注意表头节点的层高并不计算在内。

### 总结

* 跳跃表是有序集合的底层实现之一。
* Redis 的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点、尾节点、长度),而zskiplistNode则用于表示跳跃表节点。
* 每个跳跃表节点的层高都是1至32之间的随机数。
* 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
* 跳跃表中的节点按照分值大小进行排序,当分值相同时，节点按照成员对象的大小进行排序。

## 整数集合

整数集合( intset)是集合键的底层实现之一，当一个集合只包含整数值元素,并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。

### 整数集合的实现

```c
typedef struct intset{
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组 
    int8_t contents[];
}intset;
```

* contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项( item),各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。
* length属性记录了整数集合包含的元素数量，也即是contents数组的长度。
* 虽然intset结构将contents声明为int8_t类型的数组，但实际上contents数组并保持任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值。

### 升级

#### 升级步骤

每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级( upgrade ),然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步进行:

* 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
* 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放在中确定位置，并且在分支元素过程中，继续维持底层数组的有序性质不变
* 将新元素添加到底层数组里面。

#### 升级后的新元素的位置

新元素要么大于现有元素，要么小于现有元素。

* 在新元素小于所有元素，他就会被放在底层数组最开始（索引0）.
* 在新元素大于所有元素的情况，新元素会被放在底层数组的最末尾（索引 lengh-1）

#### 升级的好处

* 提升灵活性：整数集合可以通过自动升级底层数组来适应新元素，不必担心出现类型错误。
* 节约内存：既能让集合同时保存san中不同的类型的值，也能确保升级再在需要的时候才进行。

### 总结

* 整数集合是集合键的底层实现之一。
* 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素,在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。
* 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
* 整数集合只支持升级操作,不支持降级操作。

## 压缩列表

是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

### 压缩列表的构成

![image-20210517163642148](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517163642148.png)

![image-20210517163655919](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517163655919.png)

### 压缩结点的构成

![image-20210517163726165](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517163726165.png)

* previous_entry_length:保存前一个结点的长度，方便由后到前的遍历。长度不一
* encoding：记录结点content属性保存的数据类型，以及长度。
* content：保存结点的值。

### 连锁更新问题

由于前面的新元素长度大于previous_entry_length的保存范围，导致当前结点previous_entry_length需要扩大，然后一直对后面的结点产生影响。

![image-20210517164135540](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517164135540.png)

* 因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(M),所以连锁更新的最坏复杂度为0(N)。
* 要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的:
  * 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点, 连锁更新才有可能被引发,在实际中，这种情况并不多见;
  * 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如对三五个结点进行连锁更新是绝不会影响性能
* 由此：ziplistPush等命令平均复杂度只有O（N)

### 总结

* 压缩列表是一种为节约内存而开发的顺序型数据结构。
* 压缩列表被用作列表键和哈希键的底层实现之一。
* 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
* 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作,但这种操作出现的几率并不高。

## 对象

### 对象类型以及对应编码类型

#### 对象的结构

```c
typedef struct redisObject{
	//类型
    unsigned type: 4;
    //编码
    unsigned encoding :4;
    //指向底层实现数据结构的指针
    void *ptr;
    //引用计数
    int refcount;
    //最后一次被命令程序访问的时间
    unsigned lru:22;
}
```

#### 对象类型

![image-20210519192242047](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210519192242047.png)

#### 对象实现的方式

![image-20210519192335452](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210519192335452.png)

#### 不同类型对象对应的实现方式

![image-20210519192410685](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210519192410685.png)

### 字符串对象

#### 编码方式

* int：如果字符串对象保存的是整数值
* raw：如果字符串对象保存的是字符串值，并且长度大于32，就利用sds保存，编码也就是raw。
* embstr：如果字符串对象保存的是字符串，长度小于等于32，利用这个方式保存。

**embstr和raw的区别是**

* raw会调用两次内存分配函数分别创建：redisObject和sdshdr。而embstr只调用一次，来分配一块连续的空间，包括redisObject和sdshdr两个结构

**embstr的优点**

* embstr 编码将创建字符串对象所需的内存分配次数从raw编码的两次降低为一次。
* 释放embstr编码的字符串对象只需要调用一次内存释放函数,而释放raw编码的字符串对象需要调用两次内存释放函数。
* 因为embstr编码的字符串对象的所有数据都保存在一块连续的内存里面，所以这种编码的字符串对象比起raw编码的字符串对象能够更好地利用缓存带来的优势。

### 列表对象

#### 编码方式

* ziplist：保存的所有字符串元素都小于64字节并且保存的元素少于512个。
* linkedlist：不满足以上任一条件，就使用linkedlist

### 哈希对象

#### 编码方式

* ziplist：保存的所有键值对的键和值的字符串长度都小于64字节并且保存的键值对数量小于512；
* hashtable：不能满足以上任一条件，就使用hashtable。

**注：上限可以改**

### 集合对象

#### 编码方式

* intset：保存的所有元素都是整数值，并且数量不超过512.
* hashtable：不能满足以上任一条件，就使用hashtable。

### 有序集合对象

#### 编码方式

* ziplist：所有元素长度都小于64字节，并且数量小于128个
* skiplist：不能满足以上任一条件，就使用skiplist

类型检查和命令多态

### 内存回收

#### 引用计数法

* 在创建一个新对象时，引用计数的值会被初始化为1;
* 当对象被一个新程序使用时，它的引用计数值会被增一;
* 当对象不再被一个程序使用时，它的引用计数值会被减一;
* 当对象的引用计数值变为0时，对象所占用的内存会被释放。

**生命周期**

创建对象，操作对象，释放对象

### 对象共享

在Redis中，让多个键共享同一个值对象需要执行以下两个步骤:

* 将数据库键的值指针指向一个现有的值对象;
* 将被共享的值对象的引用计数增一。

### 对象空转时长

命令`OBJECT IDLETIME 对象`

OBJECT IDLETIME命令的实现是特殊的，这个命令在访问键的值对象时，不会修改值对象的lru属性。

### 总结

* Redis 数据库中的每个键值对的键和值都是一一个对象。
* Redis 共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。
* 服务器在执行某些命令之前，会先检查给定键的类型能否执行指定的命令，而检查一个键的类型就是检查键的值对象的类型。
* Redis 的对象系统带有引用计数实现的内存回收机制，当一个对象不再被使用时， 该对象所占用的内存就会被自动释放。
* Redis会共享值为0到9999的字符串对象。
* 对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的空转时间。

## 过期数据操作

### 保存过期键的方式

**过期字典**

* 过期字典的键是一个指针，这个指针指向键空间的某个键对象（也就是某个数据库键）
* 过期字典的值是一个long long类型的整数，这个整数保存了 键指向的数据库键的过期时间——一个毫秒精度的UNIX时间戳

### 过期键的判定流程

* 检查给定键是否存在于过期字典，如果存在，那么取得键的过期时间。
* 检查当前UNIX时间戳是否大于键的过期时间：如果是的化，那么键已经过期；否则的话，键未过期。

### 过期键的删除策略

* **定时删除：**再设置键的过期时间的同时，创建一个定时器，让定时器在见过其来临时，立即执行对键的删除操作。**cpu时间不友好，对内存友好**
* **惰性删除：**放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回改键。**cpu友好，对内存不友好**
* **定期删除：**每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

**注：**redis使用的是，**惰性删除**和**定期删除**

### AOF,RDB，复制功能对过期键的处理

#### RDB

**生成RDB文件**：只保存未过期的键

**载入RDB文件：** 以主服务器运行，只载入未过期键。从 服务器运行，会保留所有键值。

#### AOF

**AOF写入：**载入时，如果键还没被删除， 不会因为过期而产生影响，当被删除的时候，程序会追加del命令。

**AOF重写：** 重写过程，会对键进行检查，过期键不会保存到AOF文件中。

#### 复制

* 主服务器在删除-一个过期键之后，会显式地向所有从服务器发送-个DEL命令,告知从服务器删除这个过期键。
* 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。
* 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。

### 总结

* Redis 服务器的所有数据库都保存在redisServer . db数组中，而数据库的数量则由redisServer . dbnum属性保存。
* 客户端通过修改目标数据库指针，让它指向redisServer . db数组中的不同元素来切换不同的数据库。
* 数据库主要由dict和expires两个字典构成，其中dict字典负责保存键值对,而expires字典则负责保存键的过期时间。
* 因为数据库由字典构成，所以对数据库的操作都是建立在字典操作之上的。
* 数据库的键总是一个字符串对象，而值则可以是任意-种Redis对象类型，包括字符串对象、哈希表对象、集合对象、列表对象和有序集合对象，分别对应字符串键、哈希表键、集合键、列表键和有序集合键。
*  expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一一个以毫秒为单位的UNIX时间戳。
* Redis使用惰性删除和定期删除两种策略来删除过期的键:惰性删除策略只在碰到过期键时才进行删除操作，定期删除策略则每隔-段时间主动查找并删除过期键。
* 执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键。.
* 执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键。
* 当一个过期键被删除之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式地删除过期键。
* 当主服务器删除-个过期键之后，它会向所有从服务器发送一条DEL命令，显式地删除过期键。
* 从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统- +、 中心化的过期键删除策略可以保证主从服务器数据的一致性。
* 当Redis命令对数据库进行修改之后,服务器会根据配置向客户端发送数据库通知。