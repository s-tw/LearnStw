## 简单动态字符串

### SDS的实现

```c
struct sdshdr{
    //记录buf数组中 已使用字节的数量
    //等于SDS所保存字符串的长度
    int len;
    //记录buf数组中未使用字节的数量
    int free;
    //字节数组，用于保存字符串
    char buf[]
}sdshdr;
```

### SDS与C字符串的区别

* **获取字符串长度的复杂度不同**，

  * SDS为O(1),C为O(N)

* **杜绝缓存区溢出**

  * 由于不记录长度，在执行拼接字符串时候，会存在数据溢出的错误。
  * SDS会检查空间是否满足修改所需的要求，如果不够，会扩展SDS的空间，在拼接

* **减少修改字符串是带来的内存重分配次数**

  * c语言的内存重分配机制

    * **增长操作**，需要内存重分配来扩展底层数组空间大小，否则会产生缓存区溢出
    * **缩短操作**，需要释放不在使用的空间，否则会产生内存泄露

  * SDS中存在free属性在记录未使用字节数。

    * **空间预分配**

      不仅会分配必须要的空间，还会为SDS分配额外的未使用空间。

      ​	**公式：**

      SDS长度小于1MB，分配相同大小的长度

      SDS长度大于1MB，分配1MB的free长度

    * **惰性空间释放**

      实际上并不释放空间，而是增加free的长度

* **二进制安全**

  * c中字符串只能保存文本，不能保存二进制数据。

    * 例如如果出现

      ![image-20210506224819242](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506224819242.png)

    * c字符串只能识别“Redis”会忽略后面的"Cluster"

  * SDS的api会以处理二进制的方式来处理数组的数据。写入时是什么样，读出就是什么样。

* **兼容部分c字符串函数**

  * 爆裂数据末尾的空字符，以保证可以重用一部分< String.h>库定义的函数。
  * 

### 总结

![image-20210506225247182](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225247182.png)

![image-20210506225342615](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225342615.png)

![image-20210506225353031](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210506225353031.png)

## 链表

### 链表的实现

**节点实现**

```c
typedef struct listNode{
    //前置结点
    struct listNode * prev;
    //后置结点
    struct listNode * next;
    //节点的值
    void * value;
}listNode;
```

**链表实现**

```c
typedef struct list{
    //表头节点
    struct listNode * head;
    //表尾节点
    struct listNode * tail;
    //链表所包含的节点数量
    unsigned long len;
    //节点值复制函数
    void *(*dup)(void * ptr);
    //节点值释放函数
    void *(*free)(void * ptr);
    //节点值比较函数
    int (*match)(void *ptr,void *key)
}list;
```

### 结构示意图

![image-20210507092036078](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092036078.png)

### 链表特性

* 双端:链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是0(1)。
* 无环:表头节点的prev指针和表尾节点的next指针都指向NULL,对链表的访问以NULL为终点。
* 带表头指针和表尾指针:通过list结构的head指针和tail指针，程序获取链表的表头节点和表尾节点的复杂度为0(1)。
* 带链表长度计数器:程序使用list结构的len属性来对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为0(1)。
* 多态:链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

### 总结

![image-20210507092154901](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092154901.png)

![image-20210507092219381](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092219381.png)

![image-20210507092229887](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210507092229887.png)

## 字典

### 字典的实现

Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。

#### 哈希表

```c
typedef struct dictht {
        //哈希表数组
        dictEntry **table;
        //哈希表大小
        unsigned long size;
        //哈希表大小掩码，用于计算索引值
        //总是等于size-1
        unsigned long sizemask; .
        //该哈希表已有节点的数量
        unsigned long used;
} dictht;

```

* table属性是一个数组，数组中的每个袁术都是指向dict.h/dictEntry 结构的指针，每个dictEntry结构保存着一个键值对，

* size属性记录了哈希表的大小，也就是table数组的大小

* used属性则记录了哈希表目前已有节点（键值对）的数量。

* sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面

* 图示一个大小为4的空哈希表（没有包括任何键值对）。

  ![image-20210516155817469](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516155817469.png)

#### 哈希表节点

哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对。

```c
typedef struct dictEntry {
    //键
    void *key;
    //值
    union{
    	void val; .
    	uint64_ tu64;
    	int64_ ts64;
    } V;
    //指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;

```

​	key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是-一个指针，或者是-一个uint64_ t整数，又或者是-一个int64_ t整数。
​	next属性是指向另-一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突( collision)的问题。
​	举个例子，图4-2就展示了如何通过next指针，将两个索引值相同的键k1和k0连
接在一起。

![image-20210516160417669](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516160417669.png)

#### 字典

Redis中的字典始有dict.h/dict结构表示

```c
typedef struct dict{
    
    //类型特定函数
    dicType *type;
    
    //私有数据
    void *privdata;
    
    //哈希表
    dictht ht[2];
    
    //rehash 索引
    //当rehash不在进行时，值为-1；
    in trehashidx;
}
```

type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置。

* type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。
* 而privdata属性则保存了需要传给哪些类型特定函数的可选参数。

```c
typedef  struct dictType{
    
    //计算哈希值的函数
    unsigned int (*hashFunction){const void * key};
    
    //复制键的函数
    void *(*keyDup){void *privdata,const void *key};
    
    //复制值的函数
    void *(*valDup){void *privdata,const void *obj};
    
    //对比键的函数
    int (*keyCompare){void *privdata,const void *key1,const void *key2};
    
    //销毁键的函数
    void (*keyDestructor){void *privdata,void *key};
    
    //销毁值的函数
    void (*valDestructor){void *privdata,void *obj};
    
}dictType;
```

* ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表, 一般情况下，字典只使用ht [0]哈希表，ht[1] 哈希表只会在对ht [0]哈希表进行rehash时使用。
* 除了ht[1]之外，另一个和rehash有关的属性就是rehashidx,它记录了
  rehash目前的进度，如果目前没有在进行rehash,那么它的值为-1。

![image-20210516161933979](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516161933979.png)

### 哈希算法

​	当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

**redis计算哈希值和索引的方法如下：**

* 使用字典设置的哈希函数和哈希值，计算键key的哈希值

  hash=dict->type->hashFunction(key)

* 使用哈希表的sizemask属性和哈希值，计算出索引值

* 根据情况的不同，ht[x]可以是ht[0]或者是ht[1]

  index=hash&dict->ht[x].sizemask;

**例子：**

![image-20210516163517391](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516163517391.png)

对于以上这个字典，如果我们要将一个简直对k0和v0添加到字典里面，那么程序会先使用语句：

hash=dict->type->hashFunction(k0);

计算键k0的哈希值。

假设计算得出的哈希值为8，那么程序会继续使用语句：

index=hash&dict->ht[0].sizemask=8&3=8;

计算出键k0的索引值0，这表示包含键值对k0和v0的节点应该被放置到哈希表数组的索引0位置上，如下图所示

![image-20210516163951542](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516163951542.png)

### 解决键冲突

* 当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突( collision )。

* Redis的哈希表使用链地址法( separate chaining )来解决键冲突,每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。

* 举个例子，假设程序要将键值对k2和v2添加到图4-6所示的哈希表里面,并且计算得出k2的索引值为2，那么键k1和k2将产生冲突，而解决冲突的办法就是使用next指针将键k2和k1所在的节点连接起来，如图4-7所示。

* 因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑,程序总是将新节点添加到链表的表头位置(复杂度为0(1)),排在其他已有节点的前面。

  ![image-20210516164210560](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210516164210560.png)

### rehash

#### rehash步骤

​	随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子( load factor)维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。
​	扩展和收缩哈希表的工作可以通过执行rehash (重新散列)操作来完成，Redis 对字典的哈希表执行rehash的步骤如下:

* 为字典的ht[1]哈希表分配空间,这个哈希表的空间大小取决于要执行的操作，以
  及ht[0]当前包含的键值对数量( 也即是ht [0] .used属性的值):
  * 如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht [0] .used*2
    的2"(2的n次方幂);
  * 如果执行的是收缩操作,那么ht [1]的大小为第一个大于等于ht[0] .used的2"。
* 将保存在ht[0]中的所有键值对rehash到ht[1]上面: rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht [1]哈希表的指定位置上。
* 当ht[0]包含的所有键值对都迁移到了ht[1]之后(ht[0]变为空表),释放ht[0]，将ht[1]设置为ht[0],并在ht[1]新创建一个空白哈希表,为下一次rehash做准备。

#### 收缩和扩展的条件

当以下条件中的任意一个被满足时, 程序会自动开始对哈希表执行扩展操作:

* 服务器目前没有在执行BGSAVE命令或者BGREWRITEAOF命令,并且哈希表的负载因子大于等于1。
* 服务器目前正在执行BGSAVE命令或者BGREWRITEAOF命令，并且哈希表的负载因子大于等于5。
  * 根据BGSAVE命令或BGREWRITEAOF命令是否正在执行，服务器执行扩展操作所需的负载因子并不相同，这是因为在执行BGSAVE命令或BGREWRITEAOF命令的过程中，Redis 需要创建当前服务器进程的子进程，而大多数操作系统都采用写时复制( copy-on-write )技术来优化子进程的使用效率,所以在子进程存在期间，服务器会提高执行扩展操作所需的负载因子，从而尽可能地避免在子进程存在期间进行哈希表扩展操作，这可以避免不必要的内存写人操作，最大限度地节约内存。
* 另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作。

### 渐进式rehash

#### 渐进式rehash的步骤

以下是哈希表渐进式rehash的详细步骤:

* 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
* 在字典中维持一个索引计数器变量rehashidx,并将它的值设置为0,表示rehash
  工作正式开始。
* 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
* 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。

渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量。

#### 渐进rehash时，哈希操作

因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除(delete)查找(fnd)、更新( update)等操作会在两个哈希表上进行。例如，要在字典里面查找-一个键的话,程序会先在ht[0]里面进行查找，如果没找到的话，就会继续到ht [1]里面进行查找，诸如此类。
另外，在渐进式rehash执行期间,新添加到字典的键值对一律会被保存到ht[1]里面,而ht [0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。

### 总结

* 字典被广泛适用于redis的各种功能，包括数据库和哈希键。
* redis中的redis使用哈希表作为底层实现，每个字典带有两个哈希表，一个平时使用，另外一个rehash时使用
* 当字典被用作数据库的底层实现，或者哈希键的底层实现时，redis使用MurmurHash2算法来计算键的哈希值。
* 哈希表使用链地址法来解决键冲突，被分配到同一个索引的多个键值对会连接成一个单向链表。
* 在对哈希表进行扩展或者收缩时，程序需要将现有哈希表包括的所有键值对rehash到新的哈希表里面，并且这个rehash过程并不是一次性完成的，而是渐进式完成的。

## 跳跃表

### 跳跃表的实现

![image-20210517152439362](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517152439362.png)

* zskiplist 结构
  * header：指向跳跃表的表头
  * tail：指向跳跃表的表尾节点
  * level：记录目前跳跃表内，层数最大的那个节点的层数（表头结点的层数不计算在内）。
  * length：记录跳跃表的长度，也即是，跳跃表目前包含结点的数量（表头结点不计算在内）。
* zskipNode结构
  * level：每层都有两个属性，前进指针和跨度。
  * backward：后退指针，指向位于当前结点的前一个结点。
  * score：分值
  * obj：结点保存的成员对象

#### 跳跃表节点

```c
typedef struct zskiplistNode{
    //层
    struct zskiplistLevel{
        //前进指针
        struct zskiplistNode *forward;
        //跨度
        unsigned int span;
    }level[];
    //后退指针
    struct zskiplistNode *backward;
    //分值
    double score;
    //成员对象
    robj *obj;
}zskiplistNode;
```

* 层：level数组，包含指向其他结点的指针。
  * 程序根据幂次定律（越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level的数组大小，这个大小就是层的高度。
* 前进指针：定义为层中的forword
* 跨度：表示记录两个结点之间的距离。
  * 主要是为了计算排位，在查找结点的过程中，将沿途访问过的所有层的跨度累计起来，得到的就是目标结点的排位。
* 后退指针：从表尾到头的方向访问结点，只能访问前一个结点。
* 分值：double类型
* 成员对象obj：是一个指针，指向字符串对象。字符串对象保存一个sds值。

#### 跳跃表

```c
typedef struct zskiplist{
    //表头结点和表尾结点
    structz skiplistNode *header,*tail;
    //表中结点的数量
    unsigned long length;
    //表中层数最大的结点层数
    int level;
}zskiplist；
```

* header和tail指针分别指向跳跃表的表头和表尾节点，通过这两个指针，程序定位表头节点和表尾节点的复杂度为0(1)。
* 通过使用length属性来记录节点的数量,程序可以在0(1)复杂度内返回跳跃表的长度。
* level属性则用于在0(1)复杂度内获取跳跃表中层高最大的那个节点的层数量,注意表头节点的层高并不计算在内。

### 总结

* 跳跃表是有序集合的底层实现之一。
* Redis 的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息(比如表头节点、尾节点、长度),而zskiplistNode则用于表示跳跃表节点。
* 每个跳跃表节点的层高都是1至32之间的随机数。
* 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。
* 跳跃表中的节点按照分值大小进行排序,当分值相同时，节点按照成员对象的大小进行排序。

## 整数集合

整数集合( intset)是集合键的底层实现之一，当一个集合只包含整数值元素,并且这个集合的元素数量不多时，Redis 就会使用整数集合作为集合键的底层实现。

### 整数集合的实现

```c
typedef struct intset{
    //编码方式
    uint32_t encoding;
    //集合包含的元素数量
    uint32_t length;
    //保存元素的数组 
    int8_t contents[];
}intset;
```

* contents数组是整数集合的底层实现:整数集合的每个元素都是contents数组的一个数组项( item),各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。
* length属性记录了整数集合包含的元素数量，也即是contents数组的长度。
* 虽然intset结构将contents声明为int8_t类型的数组，但实际上contents数组并保持任何int8_t类型的值，contents数组的真正类型取决于encoding属性的值。

### 升级

#### 升级步骤

每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级( upgrade ),然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步进行:

* 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
* 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放在中确定位置，并且在分支元素过程中，继续维持底层数组的有序性质不变
* 将新元素添加到底层数组里面。

#### 升级后的新元素的位置

新元素要么大于现有元素，要么小于现有元素。

* 在新元素小于所有元素，他就会被放在底层数组最开始（索引0）.
* 在新元素大于所有元素的情况，新元素会被放在底层数组的最末尾（索引 lengh-1）

#### 升级的好处

* 提升灵活性：整数集合可以通过自动升级底层数组来适应新元素，不必担心出现类型错误。
* 节约内存：既能让集合同时保存san中不同的类型的值，也能确保升级再在需要的时候才进行。

### 总结

* 整数集合是集合键的底层实现之一。
* 整数集合的底层实现为数组，这个数组以有序、无重复的方式保存集合元素,在有需要时，程序会根据新添加元素的类型，改变这个数组的类型。
* 升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。
* 整数集合只支持升级操作,不支持降级操作。

## 压缩列表

是列表键和哈希键的底层实现之一。当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

### 压缩列表的构成

![image-20210517163642148](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517163642148.png)

![image-20210517163655919](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517163655919.png)

### 压缩结点的构成

![image-20210517163726165](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517163726165.png)

* previous_entry_length:保存前一个结点的长度，方便由后到前的遍历。长度不一
* encoding：记录结点content属性保存的数据类型，以及长度。
* content：保存结点的值。

### 连锁更新问题

由于前面的新元素长度大于previous_entry_length的保存范围，导致当前结点previous_entry_length需要扩大，然后一直对后面的结点产生影响。

![image-20210517164135540](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210517164135540.png)

* 因为连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的最坏复杂度为O(M),所以连锁更新的最坏复杂度为0(N)。
* 要注意的是，尽管连锁更新的复杂度较高，但它真正造成性能问题的几率是很低的:
  * 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点, 连锁更新才有可能被引发,在实际中，这种情况并不多见;
  * 其次，即使出现连锁更新，但只要被更新的节点数量不多，就不会对性能造成任何影响：比如对三五个结点进行连锁更新是绝不会影响性能
* 由此：ziplistPush等命令平均复杂度只有O（N)

### 总结

* 压缩列表是一种为节约内存而开发的顺序型数据结构。
* 压缩列表被用作列表键和哈希键的底层实现之一。
* 压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值。
* 添加新节点到压缩列表，或者从压缩列表中删除节点，可能会引发连锁更新操作,但这种操作出现的几率并不高。