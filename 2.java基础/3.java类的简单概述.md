###### java构造器

**重载**

* 有些类有多个构造器，可以定义对象的初始状态,但是需要注意的是，方法签名（也就是方法参数的数量和类型）需要不同。

**初始化**

* 通过构造器我们可以直接将值赋给实例域
* 但构造器方法参数和实例域命名相同时，可以用this指代

* 对于未在构造器当中初始化的域，对于数值型默认设置为0，布尔型默认为false
* 未有初始化的对象变量将设置为null

**无参构造器**

* 定义类时未声明任何构造器时，将会一个默认的无参构造器
* 当只声明有参构造器时，默认的无参构造器将无法使用，需要自行定义

**可以调用另外一个构造器** 

* 利用this

###### 初始化块

在类声明时候可以通过代码块来初始化，只要构造类的对象，这些块就会被执行

**注意:**不同初始化语句，将通过类声明出现次序，依次执行所有的域初始化语句和初始化块

###### 隐式参数和显式参数

类声明的参数，方法中声明的参数

###### 封装

* 一个私有的数据域
* 一个公有的域访问器方法
* 一个公有的域更改器方法

**注** ：类中定义的变量如果不是基本类型，那么利用访问器将直接指向对象的地址，也就是可以利用访问器来对类中变量进行修改的。这破坏了封装的要求：所以可以访问器应当返回的是对象的克隆。

###### 访问权限

|               | 同一个类 | 同一个包 | 不同包的子类 | 不同包的非子类 |
| ------------- | -------- | -------- | ------------ | -------------- |
| public        | √        | √        | √            | √              |
| protected     | √        | √        | √            |                |
| 默认(default) | √        | √        |              |                |
| private       | √        |          |              |                |

###### final实例域（实例变量）

public（访问权限） type a

* 对于基本类型域，或者不可变类的域（例如String），在声明之后，将无法修改他的值。

* 对于可变的类，在声明之后，引用只能指向固定的对象。但是对象中的值是可以改变的

##### 静态域和静态方法

###### 静态域（静态变量）

**public（访问权限） static type a**

对所有实例域都有自己的拷贝，也就是对于同一个类声明的众多对象，其对象中的实例变量和对象数量一样多，而静态域只有一个。它属于类，不属于任何独立的变量

###### 静态常量

**public（访问权限） static final type b**

如果没有final修饰，那么所有对象都可以对公有域进行修改。而使用final修饰就可以避免这样的情况发生

###### 静态方法

静态方法是不能访问实例域，也不能调用实例方法。但是可以调用静态变量。使用静态方法不需要创建对象，可以通过  类名.方法名(参数)  来调用。

**注：** 不能调用实例域和实例方法的原因是。静态方法和静态常量都在编译的时候已经产生。也就是还没开始使用main方法之前，已经存在了。而实例方法，实例变量都是在定义对象之后才开辟的空间，然后才定义和声明的。也就是静态方法和静态域先于实例方法和实例域声明的。因而静态方法和静态域不能调用实例。

###### 工厂方法

也就是利用静态方法来构造格式化对象：A a=A.getType(); A b=A.getType2();

**注：** 不利用构造器实现的原因：

* 无法命名构造器。构造器的名字必须和类名相同。但是我们希望的是得到两个格式的对象
* 当使用构造器时，无法改变 所构造对象的对象类型，但是 工厂方法可以返回一个子类的对象

###### 方法参数

java方法参数的调用时按值传递