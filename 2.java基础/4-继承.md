#### 继承

注：java中继承只能单继承

##### 类、子类、超类

* 定义子类的关键词时extends
* 利用extends继承的一般叫做子类，被继承的一般称为父类或者（超类）
* object类是所有类的父类

##### 覆盖方法

* 但出现父类方法不适用于子类方法时，我们可以通过重写方法来达到我们的目的
* 覆盖方法是可能出现调用父类私有变量的情况，原则上private修饰的变量是不能被直接访问的，所以我们可以通过访问器（get方法）来访问，需要注意的一点是，我们应当调用的是父类的访问器，而不是当前类的的访问器，所以我们可以利用super.get*()来得到父类的私有变量

##### 子类构造器

我们可以在子类的构造器来调用父类的构造器，利用super（父类构造器参数列表）

##### 继承层次

继承不仅限于一个层次，由一个公共超类派生出来所有的类的集合就是继承层次，而从某个特定类到其祖先的路径被叫做该类的继承链。

**注意：** 有同一个祖先派生出来的类，直接可能没有任何关系

##### 多态

把子类对象赋值给父类变量就是多态

例如 A是B的父类，我们可以 A a=new B(*);

注：关于多态中，子类与父类的方法调用较为复杂，存在很多种情况，这里不做多描述

##### 阻止继承

final关键词

* 利用final修饰类无法被继承
* 利用final修饰的方法无法被重写（覆盖）

##### 强制类型转换

当 B extends A时；我们可以A a=new B();

但是此时我们不能使用B类自己声明的新方法，这个时候，我们需要将a变量变成B类型，也就是

B c=（B）a；

这个时候c变量还是指向同一对象，但是可以调用其中的属于B类的方法。

**注意:** 利用强制类型转换会出现类型不匹配的情况：我们需要判断这个变量是否为该类型也就是

if（a instanceof B）{

B c=（B）a;

}

##### 抽象类

关键词：abstract

* 抽象类不能被实例化
* 抽象类中可以有实例方法
* 抽象类中可以没有抽象方法

* 就算没有抽象方法，抽象类也不能被实例化
* 类继承抽象类必须实现抽象方法，除非该子类也是抽象类 

##### equals（）方法

* 由于所有类都是object的子类，在object中有一个关于equals的方法，但是object中只是判断了两个对象的地址（也就是利用==判断），地址相同 return true 不同return false。这不满足我们的期望，我们希望的是判断类中的值。所以我们一般都需要重写equals（）方法

关于重写equals（）：

​	以下是java核心卷的建议

![image-20210414154152682](https://gitee.com/stiwen/images_bed/raw/master/img/image-20210414154152682.png)

* 重写hashcode（）方法：返回的是散列码

* 重写toString （）方法：可以将类打印输出，将对象字符串描述

#### 对象包装器与自动装箱

* 当方法中需要使用引用类型时，由于int 类型不属于引用类型，如果我们需要向方法中传值时，我们需要将int类型的值变为一个对象。这时候就需要包装类，int 对应的就是Integer。
* java提供了自动装箱机制，也就是我们向需要使用引用类型参数的方法传值时，直接使用int传值也是可以的，原因是，它自动帮我们将int型转变为Integer类型，符合了传参的要求

* java提供了自动拆箱机制，也就是如果方法返回的是Integer类型的值，我们用int来接受也是可以的，原因是，它自动帮我们将Integer转变为了int类型

**注意：Integer的128陷阱**

#### 枚举类型

定义方式：例子：public enum Size{SMALL，BIG}

* 比较对应枚举类型的值直接用==就可以
* 如果需要我们可以在枚举类型中添加构造器

```java
public enum Size{
    SMALL("S"),BIG("B");
    private String a;
    private Size(String a){this.a=a;}
    public String getA{return a;}
    
}
```

* 枚举类型都是Enum的子类